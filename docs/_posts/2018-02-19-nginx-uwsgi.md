---
layout: post
title:  "NGINX and uWSGI"
categories: Python
---
NGINX and uWSGI are so common to have in front of Python web apps that it's arguably the de facto standard.  Both NGINX and uWSGI are highly customizable applications that can do many things but to TinyFish NGINX is a reverse proxy and uWSGI is our WSGI server.  The way TinyFish works is that an HTTP request goes from the client to NGINX, which is the outermost layer.  NGINX takes the [incoming HTTP request](https://github.com/bitreef-net/tinyfish/blob/f84ad52c779530731089142e85b9ccccfa123342/Nginx/Dockerfile#L162)  and passes it to uWSGI.  NGINX does not pass an HTTP request to uWSGI however, it passes the request as a [WSGI request](https://github.com/bitreef-net/tinyfish/blob/f84ad52c779530731089142e85b9ccccfa123342/Nginx/nginx.conf#L37).  WSGI stands for Web Server Gateway Interface which is the standard API (technically it's an interface) to communicate with Python web applications.  The WSGI request is received by uWSGI and uWSGI [talks](https://github.com/bitreef-net/tinyfish/blob/f84ad52c779530731089142e85b9ccccfa123342/app/uwsgi.ini#L4) to our Flask application.  Flask processes the request, sends it back to uWSGI which goes back to NGINX and NGINX passes the response to the client.

So why NGINX?  NGINX offers many benefits.  It is known for being extremely fast, excellent at caching static resources and has a reputation for security.  Truth be told, we don't really need NGINX for TinyFish at this point.  Maybe we will go into static assets caching in a later post.  As the project move's on, I'd feel more comfortable putting NGINX on the internet facing side of a server than I would uWSGI, mostly because I've never exposed uWSGI directly.  So really we could cut NGINX out the TinyFish stack if we had to.  So having NGINX is really my personal preference.

So we know why we have NGINX now but why uWSGI?  We need a server that speaks WSGI natively but there are other options besides uWSGI.  Another popular choice is Gunicorn.  I've worked more with uWSGI and so I chose it out partially out of familiarity but also because of the massive amount of features and options uWSGI offers.  There are so many ways to configure uWSGI.  One final reason I went with uWSGI is that most documentation for Gunicorn just has NGINX doing an HTTP proxy pass, no WSGI at all.  The uWSGI documentation shows configuring NGINX to [pass WSGI](https://github.com/bitreef-net/tinyfish/blob/f84ad52c779530731089142e85b9ccccfa123342/Nginx/nginx.conf#L37) which is faster and is the proper configuration in my eyes.

The first thing that was done was to create a new container to run NGINX and uWSGI.  Building the official NGINX container can take up to a couple of minutes just on its own.  We don't want to have to wait several minutes to build NGINX every time we want to build our app.  So instead I built a container that set up the proxy side of things (NGINX and uWSGI) and tagged this container tinyfish:proxy.  Then I updated the Python container to pull from tinyfish:proxy instead of python:3.7-rc-alpine3.6 and added in a uwsgi.ini file.  In other words the NGINX container (tinyfish:proxy) will build NGINX (the app) using python:3.7-rc-alpine3.6 as the source container.  Then the TinyFish application will build itself using the NGINX container (tinyfish:proxy) that we just built.  If we need to rebuild the tinyfish:latest container it will use the cache of the tinyfish:proxy to keep our build times down.  Another possible solution would be to use what are called multi-stage builds where we can have Docker build NGINX in a container and then just copy the NGINX binary (and supporting files) to a new container where we build our app.  We don't use multi-stage builds in TinyFish currently but you should know they are an option.

So the tinyfish:proxy container started with the official NGINX Alpine Dockerfile and then adds in uWSGI.  TinyFish uses the [Python 3.7 Alpine 3.6](https://github.com/bitreef-net/tinyfish/blob/f84ad52c779530731089142e85b9ccccfa123342/Nginx/Dockerfile#L1) base container as opposed to stock Alpine3.5 used by [NGINX](https://github.com/nginxinc/docker-nginx/blob/f8fad321cf58d5cbcafa3d9fa15314b8a77b5e65/mainline/alpine/Dockerfile#L1).  I also set up supervisord which is used to start up and monitor NGINX and uWSGI.  The other thing that is done in the tinyfish:proxy container is to copy in an even smaller Python app than tinyfish.py, just to be to test the tinyfish:proxy container works properly.  We talked about Travis-CI previously and I set up a (rather primitive) test n Travis to confirm that both the tinyfish:proxy (NGINX/uWSGI) and tinyfish:latest (proxy + our flask app) both come up properly on every GitHub commit.  This way if we have to make changes to the proxy container Travis will let us know if we break it.

Although I started with the NGINX Alpine Dockerfile it was not all smooth sailing.  Building the offical NGINX container would fail more often than not and always at the same place.  I found if I put a sleep in that I had (or appeared to have) better success but there was still a lot of failing builds.  The builds were failing [here](https://github.com/bitreef-net/tinyfish/blob/f84ad52c779530731089142e85b9ccccfa123342/Nginx/Dockerfile#L92) with an error about being unable to remove files such as S.gpg-agent.ssh or S.gpg-agent.browser.  A little bit of searching and I found a Stack Overflow article about the same issue but the user was building RabbitMQ on Alpine.  The solutions was to to pkill [gpg-agent and dirmngr](https://github.com/bitreef-net/tinyfish/blob/f84ad52c779530731089142e85b09ccccfa123342/Nginx/Dockerfile#L85-L86). This is a kludge and I'm not really happy about it but it works.  The other thing I did that I'm not entirely proud of is removing the main.py file from [tinyfish:proxy](https://github.com/bitreef-net/tinyfish/blob/f84ad52c779530731089142e85b9ccccfa123342/Nginx/Dockerfile#L167) in the [tinyfish:latest](https://github.com/bitreef-net/tinyfish/blob/f84ad52c779530731089142e85b9ccccfa123342/Python/Dockerfile#L3) Dockerfile.  The main.py file from tinyfish:proxy has no business being in tinyfish:latest, I just don't like how I handled the removal.  I should deal with this in a better manner later.

Since we went to all the effort of implementing Datadog let's see what it can tell us.  So you can compare the screenshot [below]({{ site.baseurl }}/assets/images/dd-nginx-uwsgi_annotate.png) with the screenshot in the [last post]({{ site.baseurl }}/assets/images/dd-flask_annotate.png) and see the metrics are just a continuation to allow us to really get to see Flask usage side by side with  NGINX/uWSGI/Flask usage.  I ran the same `watch -n curl` command as last time except now I have to point it to port 80 where NGINX listens, so the command is `watch -n curl http://127.0.0.1` now. Here's the Datadog screenshot.

![Flask Stats]({{ site.baseurl }}/assets/images/dd-nginx-uwsgi_annotate.png)
[Full Image]({{ site.baseurl }}/assets/images/dd-nginx-uwsgi_annotate.png)

So thanks to Datadog we can see that by switching from just Flask to using NGINX and uWSGI with Flask our RAM usage more than doubled.  Our memory consumption went up to just over 41 MB when Flask alone needed just over 17 MB.  Although our memory usage has more than doubled, it's still tiny all things considered.  The point is that we now know the cost of introducing NGINX and uWSGI which is where having some metrics early on can be really useful.

