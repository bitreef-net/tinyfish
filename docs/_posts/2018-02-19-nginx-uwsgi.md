---
layout: post
title:  "NGINX and uWSGI"
categories: Python
---
NGINX and uWSGI are so common to have in front of Python web apps that they almost feel like part of a defacto standard.  Both NGINX and uWSGI are highly customizable applications that can do many things but to use NGINX is a reverse proxy and uWSGI is our WSGI server.  The way the TinyFish works is that a HTTP request goes from the client to NGINX, which is the outermost layer.  NGINX takes the [incoming HTTP request](https://github.com/bitreef-net/tinyfish/blob/f84ad52c779530731089142e85b9ccccfa123342/Nginx/Dockerfile#L162)  and passes it to uWSGI.  NGINX does not pass an HTTP request to uWSGI however, it passes the request as a [WSGI request](https://github.com/bitreef-net/tinyfish/blob/f84ad52c779530731089142e85b9ccccfa123342/Nginx/nginx.conf#L37).  WSGI stands for Web Server Gateway Interface which is the standard API to communicate with Python web applications.  The WSGI request is received by uWSGI and uWSGI [talks](https://github.com/bitreef-net/tinyfish/blob/f84ad52c779530731089142e85b9ccccfa123342/app/uwsgi.ini#L4) to our Flask application.  Flask processes the request, send it back to uWSGI which goes back to NGINX and NGINX passes the response to the client.

So why NGINX?  NGINX offers many benefits.  It is known for being extremely fast, excellent at caching static resources and has a reputation for security.  Truth be told, we don't really need NGINX for TinyFish at this point.  Maybe we will go into static assets caching in a later post.  As the project move's on, I'd feel more comfortable putting NGINX on the internet facing side of a server than I would uWSGI, mostly because I've never exposed uWSGI directly.  So really we could cut NGINX out the TinyFish stack if we had to.  So having NGINX is really my personal preference.

So we know why we have NGINX now but why uWSGI?  We need a server that speaks WSGI natively but there are other options besides uWSGI.  Another popular choice is Gunicorn.  I've worked more with uWSGI and so I chose it out partially out of familiarity but also because of the massive amount of features and options uWSGI offers.  There are so many ways to configure uWSGI.  One final reason I went with uWSGI is that most documentation for Gunicorn just has NGINX doing an HTTP proxy pass, no WSGI at all.  The uWSGI documentation shows configuring NGINX to [pass WSGI](https://github.com/bitreef-net/tinyfish/blob/f84ad52c779530731089142e85b9ccccfa123342/Nginx/nginx.conf#L37) which is faster and is the proper configuration in my eyes.

Now we know what NGINX and uWSGI and why we are using them.  I should mention up front that both NGINX and uWSGI are highly customizable, therefore sometimes we do the what is proper (such as NGINX passing WSGI instead of an HTTP proxy pass) but the configuration for TinyFish is meant to be small to avoid going too deep down a rabbit hole.  Otherwise you can spend hours read docs and tuning NGINX and uWSGI.  With that said, let's talk implementation.

The first thing that was done was to create a new container.  Building the official NGINX container can take up to a couple of minutes just on it's own.  We don't want to have to wait several minutes to build NGINX every time we want to build our app.  So we will instead build a container that to set up the proxy side of things (NGINX and uWSGI) and tag this container tinyfish:proxy.  Then we can update the Python container to pull from tinyfish:proxy instead of python:3.7-rc-alpine3.6.  In other words the NGINX container (tinyfish:proxy) will build NGINX (the app) using python:3.7-rc-alpine3.6 as the source container and then the TinyFish application will build itself using the NGINX container (tinyfish:proxy) that we just built.  Another possible solution would be to use what are called multi-stage builds where we can have Docker build NGINX in a container and then just copy the NGINX binary to a new container where we build our app.  We don't use multi-stage builds in TinyFish but you should know they are an option.

So the tinyfish:proxy container started with the official NGINX Alpine Dockerfile and then adds in uWSGI.  TinyFish uses the [Python 3.7 Alpine 3.6](https://github.com/bitreef-net/tinyfish/blob/f84ad52c779530731089142e85b9ccccfa123342/Nginx/Dockerfile#L1) base container as opposed to stock Alpine3.5 used by [NGINX](https://github.com/nginxinc/docker-nginx/blob/f8fad321cf58d5cbcafa3d9fa15314b8a77b5e65/mainline/alpine/Dockerfile#L1).  I also set up supervisord which is used to start up and monitor NGINX and uWSGI.  The other thing that is done in the tinyfish:proxy container is to copy in a an even smaller Python app than tinyfish.py, just to be to test the tinyfish:proxy container works properly.  We talked about Travis-CI previously and I set up some a (rather primitive) test to confirm that both the tinyfish:proxy (NGINX/uWSGI) and tinyfish:lastest (proxy + our flask app) both come up properly.  This way if we have to make changes to the proxy container Travis will let us know if we break it.

Although I started with the NGINX Alpine Dockerfile it was not all smooth sailing.  Building the offical NGINX container would fail more often than not and always at the same place.  I found if I put a sleep in that I had (or appeared to have) better success but there was still a lot of failing builds.  The builds here failing [here](https://github.com/bitreef-net/tinyfish/blob/f84ad52c779530731089142e85b9ccccfa123342/Nginx/Dockerfile#L92) with an error about being unable to remove files such as S.gpg-agent.ssh or S.gpg-agent.browser.  A little bit of searching and I found a Stack Overflow article about the same issue but the user was building RabbitMQ on Alpine.  The solutions was to to pkill [gpg-agent and dirmngr](https://github.com/bitreef-net/tinyfish/blob/f84ad52c779530731089142e85b09ccccfa123342/Nginx/Dockerfile#L85-L86). The other thing I did that I'm not entirely proud of is removing the main.py file from [tinyfish:proxy](https://github.com/bitreef-net/tinyfish/blob/f84ad52c779530731089142e85b9ccccfa123342/Nginx/Dockerfile#L167) in the [tinyfish:latest](https://github.com/bitreef-net/tinyfish/blob/f84ad52c779530731089142e85b9ccccfa123342/Python/Dockerfile#L3).  I should deal with this in a better manner and I will come back to fix it. 

Since we went to all the effort of implementing Datadog let's see what it can tell us.  When I wrote the last blog post about implementing Datadog I had already merged in the NGINX / uWSGI pull request.  So when I did took the Datadog stats screenshot I was running TinyFish from an old branch.  The code was the same but this meant I could switch to NGINX / uWSGI so the metrics below have both running just Flask and running NGINX with uWSGI.  So you can compare it with the screenshot in the last post and see the metrics are just a continuation to allow to really get see Flask versus NGINX/uWSGI/Flask resource consumption.  I ran the same `watch -n curl` command except now I have to point it to port 80 where NGINX listens, so the command is `watch -n curl http://127.0.0.1` now. Here's the Datadog screenshot.

![Flask Stats]({{ site.baseurl }}/assets/images/dd-nginx-uwsgi_annotate.png)
[Full Image]({{ site.baseurl }}/assets/images/dd-nginx-uwsgi_annotate.png)

So thanks to Datadog we can see that by switching from just Flask to using NGINX uWSGI and Flask our RAM usage more than doubled.  Our memory consumption went up to just over 41 MB which is just over double what Flask alone needed.  Don't just take my word for it, go look at the stats in the [Datadog post](2018-02-18-Datadog.md) when we only had Flask.  Although our memory usage has more than doubled, it's still tiny all things considered.  The point is that we now know the cost of introducing NGINX and uWSGI which is where having some metrics early on can be really useful.

