---
layout: post
title:  "Docker"
categories: Python
---

TinyFish can now be run locally, but it relies on installing things to the host.  I used a virtualenv to isolate the Python dependencies.  A Virtualenv is great but it won't help for isolating things like uwisgi or nginx.  To truly isolate things we will use Docker for containers.  I am trying to keep this blog from interfering with the actual project as much as possible but with docker there is some overlap.  I will go into more detail on the overlap shorlty.  Using containers is proving to be really handy.  For example, I originally used a VM to locally test the blog.  This was to avoid installing the Github Pages Ruby gems to my host but the VM was cumbersome.  With docker it is much easier and lighter.  Different approaches with are needed for dockerizing the TinyFish app versus the blog.  Here is what is being done with each and why.

<h3> GitHub Pages Container </h3>

This is the first container I created for TinyFish.  I really didn't want to go installing the GitHub Pages gems to my host.  So I built a container based on the <a href="https://hub.docker.com/_/ruby/">official ruby</a> container from DockerHub.  I like to use Alpine containers usually but I wanted this container to work easily as Ruby isn't my strongest langague.  Also this container will never be run anywhere but locally so the extra overhead by not using Alpine will be fine. 

I created a Dockerfile in the root of the TinyFish project and had just copied the <a href="https://github.com/bitreef-net/tinyfish/blob/d344243d98d729d36486efecaffc1f74b3b16fc9/Dockerfile.ghpages#L8">entire project folder</a> over to the container.  I knew I would have to revisit both of these choices but wanted to get this up and running quickly.  I got the container working quickly which meant I had to go back and avoid copying in the entire TinyFish project folder.  My need for the build processor for this contianer was simply to get the GitHub Pages gem and depencies installed.  So I updated the COPY in the Dockerfile to only pull in the <a href="https://github.com/bitreef-net/tinyfish/blob/d344243d98d72">bare essentials</a> needed to do the bundle install.  

So I had a container with my depencies but no actual site.   I didn't want to copy the blog in during builds so I opted to use a Docker volume.  If I had just copied the /docs/ folder in at build time I would need to rebuild the contaner every time I wanted see a change.  By using a volume I can now make my changes without the need to rebuild, even if the container is currently running.  This really lowers the feedback loop.  At this point I was satisifed enough and moved on to dockerizing TinyFish.  

<h3> TinyFish Container </h3>
The first thing I had to do was to refactor the GitHub Pages container because that DockerFile was in the site root.  I experimented with names like Dockerfile.githubpages but that still has its own problems.  For example if I use a .dockerignore file all my Dockerfiles.(resource) builds will use the same .dockerignore file.  So I ended up  moving out the Github Pages container to its own folder.  Every container I need to build will have its own folder going forward as that really is the best practice.  I don't like the naming I did for the Dockerfile folders and will go back to fix it.  In addition to moving the Dockerfile to its own folder, I had to update my <a href="https://github.com/bitreef-net/tinyfish/blob/e0a5c806fd65cbd1f4dae4a0427d153a58113e1d/GHPages-DockerFile/Dockerfile#L6">paths</a> for my COPY command. 

Now it was time to dockerize TinyFish.  I started with an <a href="https://github.com/bitreef-net/tinyfish/blob/e0a5c806fd65cbd1f4dae4a0427d153a58113e1d/TinyFish-DockerFile/Dockerfile#L1">offical Python 3.7 Alpine container</a> from <a href="https://hub.docker.com/_/python/">DockerHub</a>.  I <a href="https://github.com/bitreef-net/tinyfish/blob/5ac0b0f97a88407636e74f7fba9f4a6e845881b4/TinyFish-DockerFile/Dockerfile#L8">copy</a> in the entire TinyFish project in this container but this time I use a .dockerignore file to exclude things like the /docs/ folder which would not be needed to run the TinyFish app.  The last noteworthy change I had to make was to <a href="https://github.com/bitreef-net/tinyfish/blob/e0a5c806fd65cbd1f4dae4a0427d153a58113e1d/tinyfish.py#L15">tinyfish.py</a>.  You can't run things on 127.0.0.1 in a container because localhost in a container is not the same localhost as your host machine.  Docker sets up an internal network that is used to connect to container.  You need to serve content over this network.  For simpilcity you can serve up on all available IPs (0.0.0.0) for projects like this and Docker can handle the networking from there.  Just doing forget to <a href="https://github.com/bitreef-net/tinyfish/blob/5ac0b0f97a88407636e74f7fba9f4a6e845881b4/TinyFish-DockerFile/Dockerfile#L18">expose</a> the port you Docker to use.

So that is how I dockerized both apps.  I got to clean up the root Makefile as I no longer had to worry about running a virtualenv locally thanks to Docker.  I should set up a virtualenv in the Tinyfish container eventually.  A lot of people say there is no point but the counter-argument I have read is that installing site-wide packages is for the Operating System, virtual environments are for your code.  I can appreciate that logic.  I will try and refacor the virtaulenv in as well as redo the naming on my Dockerfile folders.  

EDIT: I went back and updated the Dockerfile folder names.  For blog context here is the orginal value and what they became:
<ul>
<li>GHPages-DockerFile => GitHubPages</li>
<li>TinyFish-DockerFile => Python</li>
</ul>
