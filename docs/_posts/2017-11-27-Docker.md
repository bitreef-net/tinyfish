---
layout: post
title:  "Docker"
categories: Python
---

TinyFish can now be run locally, but it relies on installing things to my host.  I used a virtualenv to isolate the Python dependencies.  Virtualenv is great but it won't help for isolating things like uwisgi or nginx.  To truly isolate things I will use Docker for containers.  I am trying to keep this blog seperated from the actual project as much as possible.  However using a container for GitHub Pages local testing is also handed.  I orignally used a seperate VM to avoid installing Ruby gems to my host.  Docker really worked well for this  I am taking wo different approaches with dockerizing TinyFish application versus this blog.  Here is what is being done with each and why.

<h3> GitHub Pages Container </h3>

This was the first container I created for TinyFish.  I really didn't want to go installing the gems to my host.  So I built a container based on the <a href="https://hub.docker.com/_/ruby/">official ruby</a> containes from DockerHub.  I like to use Alpine containers usually but I wanted this container to work easily as Ruby isn't my strongest langague.  Also this container will never be run anywhere but locally so the extra overhead by not using Alpine would be fine. 

I created a Dockerfile in the root of the TinyFish project and had just copied the <a href="https://github.com/bitreef-net/tinyfish/blob/d344243d98d729d36486efecaffc1f74b3b16fc9/Dockerfile.ghpages#L8">entire project folder</a> over to the container.  I knew I would have to revist both of these choices but wanted to get this up and running quickly.  I got the container working quickly which meant I had to go back and avoid copying in the entire TinyFish project folder.  My need for the build processor for this contianer was simply to get the GitHub Pages gem and depencies installed.  So I updated the COPY in the Dockerfile to only pull in the <a hred="https://github.com/bitreef-net/tinyfish/blob/d344243d98d72">bare essentials</a> needed to do the bundle install.  

So I had a container with my depencies but no actual site.   I didn't want to copy the site in during builds so I opted to use a Docker volume.  If I had just copied the /docs/ folder in at build time I would need to rebuild the contaner every time I wanted see a change.  By using a volume I can now make my change and start the container without the need to rebuild.  This really lowers the feedback loop.  At this point I was satisifed enough and moved on to dockerizing TinyFish.  


<h3> TinyFish Container </h3>
The first thing I had to do was to refactor the GitHub Pages container because this DockerFile was in the site root.  I experimented with names like Dockerfile.githubpages but that still has its own problems.  For example if I use a .dockerignore file all my Dockerfiles.(resource) builds will use the .dockerignore file.  So I ended up  moving out the Github Pages container to its own folder.  Every conttainer I need to build will have its own folder going forward as that really is the best practice.  I really don't like the naming I did for the Dockerfile folders and will go back to fix it.  In addition to moving the Dockerfile to its own folder, I had to update my <a href="https://github.com/bitreef-net/tinyfish/blob/e0a5c806fd65cbd1f4dae4a0427d153a58113e1d/GHPages-DockerFile/Dockerfile#L6">paths</a> for my COPY command. 

Now it was time to dockerize TinyFish.  I started with an <a href="https://github.com/bitreef-net/tinyfish/blob/e0a5c806fd65cbd1f4dae4a0427d153a58113e1d/TinyFish-DockerFile/Dockerfile#L1">offical Python 3.7 Alpine container</a> from <a href=>"https://hub.docker.com/_/python/"DockerHub</a>.  I <a href="https://github.com/bitreef-net/tinyfish/blob/5ac0b0f97a88407636e74f7fba9f4a6e845881b4/TinyFish-DockerFile/Dockerfile#L8">copy</a> in the entire TinyFish project in this container but this time I use a .dockerignore file to exclude things like the /docs/ folder which would need be needed to run the TinyFish app.  The last noteworthy change I had to make was to <a href="https://github.com/bitreef-net/tinyfish/blob/e0a5c806fd65cbd1f4dae4a0427d153a58113e1d/tinyfish.py#L15">tinyfish.py</a>.  You can't run things on 127.0.0.1 in a docker container because localhost in a container is not the same localhost as your host machine.  Docker sets up an internal network based on your Docker configuration.  You need to serve content on that Docker network.  For simpilcity you can serve up on all available IPs (0.0.0.0) for projects like this and Docker can handle the networking from there.  Just doing forget to <a href="https://github.com/bitreef-net/tinyfish/blob/5ac0b0f97a88407636e74f7fba9f4a6e845881b4/TinyFish-DockerFile/Dockerfile#L18">expose</a> the port you Docker to use.

So that is how I dockerized both apps.  I got to clean up the root Makefile as I no longer had to worry about running a virtualenv locally thanks to Docker.  I should set up a virtualenv in the Tinyfish container eventually.  A lot of people say there is no point but the counter-argument I have read is that installing site-wide packages is for the Operating System, virtual environments are for your code.  I can appreciate that logic.  I will try and refacor the virtaulenv in as well as redo the naming on my Dockerfile folders.  



